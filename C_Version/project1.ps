makefile

CFLAGS = -c -g
S = server_code/
CL = client_code/
CO = common/

all: server client

server: server.o network_node.o
	gcc server.o network_node.o -o server
	mv server server_code

client: client.o network_node.o
	gcc client.o network_node.o -o client
	mv client client_code

client.o: $(CL)client.c $(CL)client.h
	gcc $(CFLAGS) $(CL)client.c

server.o: $(S)server.c $(S)server.h 
	gcc $(CFLAGS) $(S)server.c

network_node.o: $(CO)network_node.c $(CO)network_node.h
	gcc $(CFLAGS) $(CO)network_node.c

clean:
	rm client_code/client
	rm server_code/server
	rm *.o


network_node.h

#ifndef  NETWORK_NODE_H
#define NETWORK_NODE_H

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdint.h>

typedef struct {
  char* delimiter;
  char* messageBegin;
  char* messageEnd;
  char* putCommand;
  char* getCommand;
}packetFields;

int networkNodeConnect(const char*, int, struct addrinfo*);

char* packetAppend(char*, const char*, const char*);

int receivePacket(int, char*, int, packetFields, uint8_t);
int receiveBytes(int, char*, int, uint8_t);

void sendPacket(const char*, int, packetFields, char* command, uint8_t);
int sendBytes(int, const char*, unsigned long int, uint8_t);

#endif


network_node.c

#define MAX_PACKET_LENGTH 5000  // Upper limit on packet size (bytes)

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/socket.h>
#include <errno.h>

#include "network_node.h"

/*
 * Name: networkNodeConnect
 * Purpose: Connect to another socket
 * Input: 
 * - Name of the node to connect to
 * - Socket on calling node process
 * - addrinfo structure containing information about node to connect to
 * Output: 
 * - Connected socket descriptor
 */
int networkNodeConnect(const char* nodeName, int socketDescriptor, struct addrinfo* destinationAddressInfo) {
  printf("Connecting to %s...\n", nodeName);
  int connectionStatus;
  connectionStatus = connect(socketDescriptor, destinationAddressInfo->ai_addr, destinationAddressInfo->ai_addrlen);
  // Check if connection was successful
  if (connectionStatus != 0) {
    char* errorMessage = malloc(1024);
    strcpy(errorMessage, strerror(errno));
    printf("Connection to %s failed with error %s\n", nodeName, errorMessage);
    exit(1);
  }
  printf("Connected to %s...\n", nodeName);
  return socketDescriptor;
}

/* 
 * Name: packetAppend
 * Purpose: Append a string to a packet and print confirmation
 * Input:
 * - Packet to append string to
 * - String to append to packet
 * - What is being added to the packet
 * Output: Packet with the new string appended to it
 */
char* packetAppend(char* destinationPacket, const char* sourceInformation, const char* informationName) {
  size_t sourceInformationLength = strlen(sourceInformation);
  destinationPacket = strncat(destinationPacket, sourceInformation, sourceInformationLength); // Add beginning of message
  printf("Added %zd byte %s to packet\n", sourceInformationLength, informationName);
  return destinationPacket;
}

/*
 * Name: sendPacket
 * Purpose: Send a packet
 * Input: 
 * - The file name to send
 * - Socket Descriptor of the socket to send the file out on
 * - Structure containing packet packet fields
 * - Which command to send (put or get)
 * - debug flag
 * Output: None
 */
void sendPacket(const char* fileName, int socketDescriptor, packetFields senderPacketFields, char* command, uint8_t debugFlag) {
  char* packet = malloc(MAX_PACKET_LENGTH);             // Allocate memory for packet
  printf("Allocated %d byte packet\n", MAX_PACKET_LENGTH);
  
  // Add beginning of message to packet
  packet = packetAppend(packet, senderPacketFields.messageBegin, "beginning of message");

  // Add command to packet
  uint8_t putCommandFlag = 0;
  // put
  if (strcmp(senderPacketFields.putCommand, command) == 0) {
    putCommandFlag = 1;
    packet = packetAppend(packet, senderPacketFields.putCommand, "put command");
  }
  // get
  else if (strcmp(senderPacketFields.getCommand, command) == 0) {
    packet = packetAppend(packet, senderPacketFields.getCommand, "get command");
  }
  else {
    printf("Invalid command passed to sendPacket()\n"); 
    exit(1);
  }

  // Add delimiter to packet
  packet = packetAppend(packet, senderPacketFields.delimiter, "delimiter");

  // Add file name to packet
  packet = packetAppend(packet, fileName, "file name");
  
  // Add delimiter to packet
  packet = packetAppend(packet, senderPacketFields.delimiter, "delimiter");

  // If file contents are to be sent
  if (putCommandFlag) {
    // Add file contents to packet
    printf("Adding contents of %s to packet\n", fileName);
    // Open the file
    int fileDescriptor;
    printf("Opening file %s...\n", fileName);
    fileDescriptor = open(fileName, O_CREAT, O_RDWR);	// Create if does not exist + read and write mode
    if (fileDescriptor == -1) {
      char* errorMessage = malloc(1024);
      strcpy(errorMessage, strerror(errno));
      printf("Failed to open file \"%s\" with error %s\n", fileName, errorMessage);
      exit(1);
    }
    printf("File %s opened\n", fileName);

    // Get the size of the file in bytes
    struct stat fileInformation;
    if (stat(fileName, &fileInformation) == -1) {
      printf("Stat Error\n");
      exit(1);
    };
    unsigned long int fileSize = fileInformation.st_size;
    printf("%s is %ld bytes\n", fileName, fileSize);

    // Read out the contents of the file
    char* fileContents = malloc(100000);
    printf("Reading file...\n");
    ssize_t bytesReadFromFile = 0;
    bytesReadFromFile = read(fileDescriptor, fileContents , fileSize);
    if (bytesReadFromFile == -1) {            // read failed()
      char* errorMessage = malloc(1024);
      strcpy(errorMessage, strerror(errno));
      printf("Failed to read file \"%s\" with error %s\n", fileName, errorMessage);
      exit(1);
    }
    else {
      printf("%zd bytes read from %s\n", bytesReadFromFile, fileName);
    }
    
    // Add file contents to packet
    packet = packetAppend(packet, fileContents, "file contents");
  }
  // get
  else {
    char* dummyFileContents = malloc(1);  // No contents sent with a get command
    packet = packetAppend(packet, dummyFileContents, "dummy file contents");
  }

  // Add message end to packet
  packet = packetAppend(packet, senderPacketFields.messageEnd, "message end");
  
  // Print out the packet that is going to be sent
  printf("%zd byte packet to be sent: %s\n", strlen(packet), packet);

  // Send the packet
  printf("Sending packet...\n");
  int bytesSent = sendBytes(socketDescriptor, packet, strlen(packet), debugFlag);
  printf("%d byte packet sent\n", bytesSent);
}

/*
 * Name: sendBytes
 * Purpose: Send a desired number of bytes out on a Socket
 * Input:
 * - Socket Descriptor of the socket to send the bytes with
 * - Buffer containing the bytes to send
 * - Amount of bytes to send
 * - Debug flag
 * Output: Number of bytes sent
 * Notes: need to change variable names to be more ambiguous
 */
int sendBytes(int socketDescriptor, const char* buffer, unsigned long int bufferSize, uint8_t debugFlag) {
  if (debugFlag) {
    // Print the bytes to send
    printf("Bytes to be sent:\n\n");
    int i;
    for (i = 0; i < bufferSize; i++) {
      printf("%c", buffer[i]);
    }
    printf("\n \n");
  }

  int bytesSent = 0;
  bytesSent = send(socketDescriptor, buffer, bufferSize, 0);
  if (bytesSent == -1) {  
    char* errorMessage = malloc(1024);
    strcpy(errorMessage, strerror(errno));
    printf("Byte send failed with error %s\n", errorMessage);
    exit(1);
  }
  else {
    return bytesSent;
  }
}

/*
 * Name: receiveMessage
 * Purpose: This function is for receiving a set number of bytes into
 * a buffer
 * Input: 
 * - Socket Descriptor of the accepted transmission
 * - Buffer to put the received data into
 * - The size of the message to receive in bytes
 * Output: 
 * - The number of bytes received into the buffer
 */
int receiveBytes(int incomingSocketDescriptor, char* buffer, int bufferSize, uint8_t debugFlag) {
  int numberOfBytesReceived = 0;
  numberOfBytesReceived = recv(incomingSocketDescriptor, buffer, bufferSize, 0);
  if (debugFlag) {
    // Print out incoming message
    int i;
    printf("Bytes received: \n");
    for (i = 0; i < numberOfBytesReceived; i++) {
      printf("%c", buffer[i]);
    }
    printf("\n");
  }
  return numberOfBytesReceived;
}

/*
 * Name: receiveFile
 * Purpose: This function is for reading a file into the present working directory.
 * The file name will be the same as the file that was sent.
 * Input: Socket Descriptor of the accepted transmission
 * Output: None
 */
int receivePacket(int incomingSocketDescriptor, char* fileName, int fileNameSize, packetFields receiverPacketFields, uint8_t debugFlag) {
  char* incomingPacket = malloc(MAX_PACKET_LENGTH); // Allocate space for incoming packet
  int totalBytesReceived = 0;
  while (totalBytesReceived = recv(incomingSocketDescriptor, incomingPacket, MAX_PACKET_LENGTH, 0)) { // Constantly check the socket for data
    if (debugFlag) {
      printf("%d\n", totalBytesReceived);
    }
    if (totalBytesReceived != -1) { // Something was actually received or client closed connection
      break;
    }
  }

  if (totalBytesReceived == 0) {
    printf("Client closed connection\n");
    return 1;
  }
  printf("Receiving Packet...\n");

  printf("%d byte packet received:\n", totalBytesReceived);
  if (debugFlag) {
    printf("%s\n", incomingPacket);
  }

  printf("Parsing packet...\n");

  // Look for beginning of message
  printf("Checking for beginning of message...\n");
  if (strstr(incomingPacket, receiverPacketFields.messageBegin)) {  // Check if beginning exists
    printf("Beginning of message found\n"); 
    incomingPacket += strlen(receiverPacketFields.messageBegin);    // Advance to after beginning
  }
  else {  // Beginning of messsage not found
    printf("Invalid packet: Beginning of message not found\n");
    return 10; // change
  }

  // Check command
  uint8_t getFlag = 0;  // Whether or not get has been received
  printf("Checking command...\n");
  int commandSize = 3;  // Both commands are 3 bytes
  char* incomingCommand = malloc(commandSize);
  incomingCommand = strncpy(incomingCommand, incomingPacket, commandSize);  // Read the command off the packet
  // put
  if (strcmp(incomingCommand, "put") == 0) {  
    printf("Command found: put\n");
    // Care about file contents
  }
  // get
  else if (strcmp(incomingCommand, "get") == 0) {
    printf("Command found: get\n");
    getFlag = 1;  // Dont care about the file contents
  }
  // invalid
  else {
    printf("Invalid command received\n");
    return 10; // change
  }

  // Need to improve This
  // Assuming all is well and skipping delimiter to file name
  incomingPacket += 12;

  // Find file name
  printf("Checking file name...\n");
  char* incomingFileName = malloc(fileNameSize);
  char* nextPacketChar = malloc(1);   // So can use strcat()
  while (strstr(incomingFileName, receiverPacketFields.delimiter) == NULL) {  // while delimiter not found
    if (*incomingPacket == '\0') {    // Got to end of packet before delimiter was found
      printf("filename error\n");
      return 10; // change
    }
    // Add next packet character to file name
    nextPacketChar[0] = *incomingPacket;
    incomingFileName = strcat(incomingFileName, nextPacketChar); 
    incomingPacket++;
  }
  incomingFileName[strlen(incomingFileName) - 9] = '\0';  // Remove delimiter from file name
  printf("File name:\n%s\n", incomingFileName);

  // get
  if (getFlag) {  // Dont care about file contents, just return
    strcpy(fileName, incomingFileName);
    return 0;
  }
  // put
  else {  // Care about file contents, extract them
    // Find file contents
    printf("Checking file contents...\n");
    char* incomingFileContents = malloc(10000);
    while (strstr(incomingFileName, receiverPacketFields.messageEnd) == NULL) { // While end of message has not been encountered
      if (*incomingPacket == '\0') {  // At the end of the packet
        nextPacketChar[0] = *incomingPacket;
        incomingFileContents = strcat(incomingFileContents, nextPacketChar); 
        break;
      }
      // Not at the end of the packet
      nextPacketChar[0] = *incomingPacket;
      incomingFileContents = strcat(incomingFileContents, nextPacketChar);  // Add the next character in the packet to the file contents
      incomingPacket++;
    }
    int i;
    for (i = 0; i < 10; i++) {
      incomingFileContents[strlen(incomingFileContents) - 1] = '\0';
    }
    if (debugFlag) {
      printf("File contents:\n%s\n", incomingFileContents);
    }

    // Open and write to the new file
    int receivedFile;
    printf("Opening received file...\n");
    receivedFile = open(incomingFileName, (O_CREAT | O_RDWR), S_IRWXU);
    printf("Received file opened\n");
    printf("Writing received file...\n");
    write(receivedFile, incomingFileContents, totalBytesReceived);
    printf("Received file written\n");
  }
  return 11;
}


server.c

#define FILE_NAME_SIZE 50

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#include "../common/network_node.h"
#include "server.h"

// Global flags
uint8_t debugFlag = 0;  // Can add conditional statements with this flag to print out extra info

// Global variables (for signal handler)
struct addrinfo* serverAddressInfo;
int socketDescriptor;
int incomingSocketDescriptor;

// Forward declarations
void shutdownServer(int);

// Main fucntion
int main(int argc, char* argv[]) {
  signal(SIGINT, shutdownServer);

  packetFields serverPacketFields;
  serverPacketFields.delimiter = "delimFlag";
  serverPacketFields.messageBegin = "messageBegin";
  serverPacketFields.messageEnd = "messageEnd";
  serverPacketFields.putCommand = "put";
  serverPacketFields.getCommand = "get";


  // Check how many command line areguements passed
	switch (argc) {
		case 1:
			printf("Running server in normal mode\n");
			break;
		case 2:
			if (strcmp(argv[1], "-d") == 0) {
				debugFlag = 1;
				printf("Running server in debug mode\n");
			}
			break;
		default:
	}

	int status;
	struct addrinfo hints;

	hints.ai_family = AF_INET;        // IPV4
	hints.ai_socktype = SOCK_STREAM;  // TCP
	hints.ai_protocol = 0;            // Any protocol
	hints.ai_flags = AI_PASSIVE;      // If node is null, will bind to IP of host
	
  // Port 3940
	int getaddrinfoReturnValue;
	getaddrinfoReturnValue = getaddrinfo(NULL, "3940", &hints, &serverAddressInfo);
	if (getaddrinfoReturnValue != 0) {
		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(getaddrinfoReturnValue));	
		exit(EXIT_FAILURE);
	}
  
  // Set up socket
  printf("Setting up socket...\n");
  socketDescriptor = socket(serverAddressInfo->ai_family, serverAddressInfo->ai_socktype, 0);
  printf("Socket set up\n");

  // Bind socket
  printf("Binding socket...\n");
  bind(socketDescriptor, serverAddressInfo->ai_addr, serverAddressInfo->ai_addrlen);
  printf("Socket bound\n");
	
  // Listen
  listen(socketDescriptor, 10);		// Limit queued connections to 10

  struct sockaddr incomingAddress;
  int incomingSocketDescriptor;
  socklen_t sizeOfIncomingAddress = sizeof(incomingAddress);

  pid_t processId;

  // Continously listen for new packets
  while (1) {
    // Accept the incoming connection
    printf("Listening for connections...\n");
    incomingSocketDescriptor = accept(socketDescriptor, &incomingAddress, &sizeOfIncomingAddress);
    printf("Connection accepted\n");
    printf("Listening for data...\n");
    
    if ((processId = fork()) == 0) {
      close(socketDescriptor); 
      uint8_t clientAlive = 1;

      // Process incoming data
//      char* incomingFileName = malloc(FILE_NAME_SIZE);      // Space for file name
      fcntl(incomingSocketDescriptor, F_SETFL, O_NONBLOCK); // Set socket to non blocking (will return if no data available)
      int receivePacketReturn;

      while(clientAlive) {
        char* incomingFileName = malloc(FILE_NAME_SIZE);      // Space for file name
        receivePacketReturn = receivePacket(incomingSocketDescriptor, incomingFileName, FILE_NAME_SIZE, serverPacketFields, debugFlag);
        switch (receivePacketReturn) {
          case 0: // get command
            sendPacket(incomingFileName, incomingSocketDescriptor, serverPacketFields, serverPacketFields.putCommand, debugFlag); // Send back the requested file
            break;
          case 1: // Client connection closed
            clientAlive = 0;
            break;
          default:  // put command or error (need to improve)
            break;
        }
      }

      printf("Connection terminated\n");
      exit(0);
    }
    close(incomingSocketDescriptor);
  }
  return 0;
}

/*
* Name: shutdownServer
* Purpose: Gracefully shutdown the server when the user enters
* ctrl-c. Closes the sockets and frees addrinfo data structure
* Input: The signal raised
* Output: None
*/
void shutdownServer(int signal) {
  close(incomingSocketDescriptor);
  close(socketDescriptor);
	freeaddrinfo(serverAddressInfo);
  printf("\n");
  exit(0);
}


client.c

#define USER_INPUT_BUFFER_LENGTH 40
#define FILE_NAME_SIZE 50

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <stdio.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>
#include <errno.h>

#include "../common/network_node.h"
#include "client.h"

// Global flags
uint8_t debugFlag = 0;				// Can add conditional statements with this flag to print out extra info

// Global variables (for signal handler)
int socketDescriptor;
struct addrinfo* clientAddressInfo;

// Forward declarations
void printFileInformation(const char*, struct stat);
void shutdownClient(int);

// Main
int main(int argc, char* argv[]) {
  signal(SIGINT, shutdownClient);

  // Set packet fields
  packetFields clientPacketFields;
  clientPacketFields.delimiter = "delimFlag";
  clientPacketFields.messageBegin = "messageBegin";
  clientPacketFields.messageEnd = "messageEnd";
  clientPacketFields.putCommand = "put";
  clientPacketFields.getCommand = "get";

	switch (argc) { // Check how many command line arguments are passed
		case 1:
			printf("Running client in normal mode\n");
			break;
		case 2:
			if (strcmp(argv[1], "-d") == 0) { // Check if debug flag
				debugFlag = 1;
				printf("%s\n", "Running client in debug mode");
			}
			else {
				printf("Invalid usage of client");  // Could make this printout better
			}
			break;
    default:
			printf("Invalid usage of client");  // Could make this printout better
	}
	
	int status;
	struct addrinfo hints;

  // Setup hints 
	hints.ai_family = AF_INET;                              // Internet
	hints.ai_socktype = SOCK_STREAM;                        // TCP
	hints.ai_protocol = 0;                                  // Auto set based on family and socktype

	getaddrinfo(NULL, "3940", &hints, &clientAddressInfo);  // Port 3940

	socketDescriptor = socket(clientAddressInfo->ai_family, clientAddressInfo->ai_socktype, 0);

  // Connect to the server
  const char* nodeName = "server";
  socketDescriptor = networkNodeConnect(nodeName, socketDescriptor, clientAddressInfo);

  // Constantly check user input for a put/get command
  while(1) {
    // Get user input and store in userInput buffer
		char userInput[USER_INPUT_BUFFER_LENGTH];
    fgets(userInput, USER_INPUT_BUFFER_LENGTH, stdin);
    userInput[strcspn(userInput, "\n")] = 0;                // Remove \n

    // put
		if (userInput[0] == 'p' && userInput[1] == 'u' && userInput[2] == 't') {
      // Send file
      sendPacket(&userInput[4], socketDescriptor, clientPacketFields, clientPacketFields.putCommand, debugFlag);  
      //close(socketDescriptor);                                                                    // Close current connection
      //socketDescriptor = socket(clientAddressInfo->ai_family, clientAddressInfo->ai_socktype, 0); // New socket descriptor for next connection
		}
    // get
		else if (userInput[0] == 'g' && userInput[1] == 'e' && userInput[2] == 't') {
      // Send get command and receive file
      sendPacket(&userInput[4], socketDescriptor, clientPacketFields, clientPacketFields.getCommand, debugFlag);  // Send get command packet
      char* incomingFileName = malloc(FILE_NAME_SIZE);  // Space for file name
      fcntl(socketDescriptor, F_SETFL, O_NONBLOCK);     // Set socket to non blocking (don't wait on data)
      receivePacket(socketDescriptor, incomingFileName, FILE_NAME_SIZE, clientPacketFields, debugFlag); // Receive file packet
      //close(socketDescriptor);                                                                          // Close current connection
      //socketDescriptor = socket(clientAddressInfo->ai_family, clientAddressInfo->ai_socktype, 0);       // New socket descriptor for next connection
      
		}
    else {
      // Enter valid command (put/get)
    }
	}
	return 0;
}

/*
 * Name: printFileInformation
 * Purpose: Utilize the stat data structure to print out various bits of
 * info about a particular file. Currently only using it to print out the
 * size of the file.
 * Input: 
 * - The name of the file
 * - The stat data structure corrosponding to the file
 * Output: None
 */
void printFileInformation(const char* fileName, struct stat fileInformation) {
	printf("Information about %s:\n", fileName);
	printf("Total size, in bytes: %ld\n", fileInformation.st_size);			
}

void shutdownClient(int signal) {
  close(socketDescriptor);
	freeaddrinfo(clientAddressInfo);
  printf("\n");
  exit(0);
}

